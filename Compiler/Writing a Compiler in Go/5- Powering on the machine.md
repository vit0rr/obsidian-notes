For now, the instruction set of my bytecode are only able to express "push this constant on to the stack" and not "do something with it". So, time to get to work on the VM.

The goal for now is to build up a VM that can initialize with the **Bytecode** produced by the compiler, start and have it fetch, decode, and execute **OpConstant** instructions. The result of all that should be numbers being pushed on the VM's stack.

Let's start by copy and  paste the `parse` and **testIntegerObject** test helpers from compiler tests.

```go
// vm/vm_test.go
package vm

import (
	"fmt"

	"github.com/vit0rr/mumu/ast"
	"github.com/vit0rr/mumu/lexer"
	"github.com/vit0rr/mumu/object"
	"github.com/vit0rr/mumu/parser"
)

func parse(input string) *ast.Program {
	l := lexer.New(input)
	p := parser.New(l)
	return p.ParseProgram()
}

func testIntegerObject(expected int64, actual object.Object) error {
	result, ok := actual.(*object.Integer)
	if !ok {
		return fmt.Errorf("object is not Integer. got=%T (%+v)", actual, actual)
	}

	if result.Value != expected {
		return fmt.Errorf("object has wrong value. got=%d, want=%d",
			result.Value, expected)
	}

	return nil
}

```

And following compiler tests pattern:

```go
// vm/vm_test.go
type vmTestCase struct {
	input    string
	expected interface{}
}

func runVmTests(t *testing.T, tests []vmTestCase) {
	t.Helper()

	for _, tt := range tests {
		program := parse(tt.input)

		comp := compiler.New()
		err := comp.Compile(program)
		if err != nil {
			t.Fatalf("compiler error: %s", err)
		}

		vm := New(comp.Bytecode())
		err = vm.Run()
		if err != nil {
			t.Fatalf("vm error: %s", err)
		}

		stackElem := vm.StackTop()

		testExpectedObject(t, tt.expected, stackElem)
	}
}

func testExpectedObject(
	t *testing.T,
	expected interface{},
	actual object.Object,
) {
	t.Helper()

	switch expected := expected.(type) {
	case int:
		err := testIntegerObject(int64(expected), actual)
		if err != nil {
			t.Errorf("testIntegerObject failed: %s", err)
		}
	}
}

```

The **runVmTests** function takes care of setting up and running each **vmTestCase**: lex and parse the input, take the AST, pass it to the **compiler**, check the compiler for errors and then hand the **compiler.Bytecode** over to the **New** function.

The **New** function should return a new instance of the VM. I start the vm with a call to **vm.Run** and after making sure it ran without an error, **StackTop** method will get the object that's left sitting on top of the VM's stack. Then, pass that to **testExpectedObject** to make sure that this object matches what I expected inthe **vmTestCase.expected** field.

So, first test:
```go
// vm/vm_test.go
func TestIntegerArithmetic(t *testing.T) {
	tests := []vmTestCase{
		{"1", 1},
		{"2", 2},
		{"1 + 2", 2}, //FIXME
	}

	runVmTests(t, tests)
}
```

Note that I do not expect 3 but 2 to be sitting on top of the stack after compiling and executing 1 + 2.  But for now, I only have **OpConstant** defined, which makes the only thing we. can test and implement the pushing of constants on the stack.

Now, creating VM package:
```go
// vm/vm.go
package vm

const StackSize = 2048

type VM struct {
	constants    []object.Object
	instructions code.Instructions

	stack []object.Object
	sp    int // Always points to the next value. Top of stack is stack[sp-1]
}

func New(bytecode *compiler.Bytecode) *VM {
	return &VM{
		instructions: bytecode.Instructions,
		constants:    bytecode.Constants,

		stack: make([]object.Object, StackSize),
		sp:    0,
	}
}
```

My VM is a struct with four fields. It holds the **constants** and **instructions** generated by the **compiler** and has a **stack**. 

The **stack** is preallocated to have a **StackSize** number of elements. **sp** is the stackpointer, which I'll increment or decrement. to grow or shrink the stack, instead of modifying the **stack** slice itself.

**sp** will always point to the *next* free slot in the stack. If there's one element on the stack, located at index 0, the alue of **sp** sould be 1 and to access the element I'd use **stack[sp-1]**. A new element would be stored at **stack[sp]**, before **sp** is incremented.

Knowing this, I define the **StackTop** method I use in VM tests:
```go
// vm/vm.go
func (vm *VM) StackTop() object.Object {
	if vm.sp == 0 {
		return nil
	}

	return vm.stack[vm.sp-1]
}
```

Now, let's define the **Run** method:
```go
// vm/vm.go
func (vm *VM) Run() error {
	for ip := 0; ip < len(vm.instructions); ip++ {
		op := code.Opcode(vm.instructions[ip])

		switch op {
		}
	}

	return nil
}
```

That's the "fetch" part of the cycle. Iterate through **vm.instructions** by incrementing the. instruction pointer, **ip**, and fetch the current instruction by directly accessing **vm.instructions**. Then, turn **byte** into an **Opcode**.

Of course it does not work because. the switch are empty. Just the fetch part alone is not enough. Time to "decode" and "execute". Decoding means adding a new case branch and decoding the operands of instruction:

```go
// vm/vm.go
func (vm *VM) Run() error {
	for ip := 0; ip < len(vm.instructions); ip++ {
		op := code.Opcode(vm.instructions[ip])

		switch op {
		case code.OpConstant:
			constIndex := code.ReadUint16(vm.instructions[ip+1:])
			ip += 2

			err := vm.push(vm.constants[constIndex])
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (vm *VM) push(o object.Object) error {
	if vm.sp >= StackSize {
		return fmt.Errorf("stack overflow")
	}

	vm.stack[vm.sp] = o
	vm.sp++

	return nil
}
```

With the **code.ReadUint16** function I decode the operands in the bytecode, starting with the byte positioned right after the opcode, at **ip+1**. After this, I must be careful to increment **ip** by correct amount - the number of bytes we read to decode the operands. The result is that the next iteration of the loop starts with **ip** poiting. to an opcode instead of an operand.

I use **constIndex** to get the constant in **vm.constants** and then push it on to the stack. Now, tests pass.
```shell
âžœ go test ./vm                                                      
ok      github.com/vit0rr/mumu/vm       0.549s
```

That means I have defined my own bytecode format, built a compiler that translate a subset of Monkey into this bytecode format and created a VM that executes the bytecode.
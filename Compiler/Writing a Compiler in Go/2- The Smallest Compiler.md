Now that I have a toolbox called `code`, I can start working on the compiler. The compiler should only do one thing for now: produce two `OpConstant` instructions that later cause the VM to correctly load the integers `1` and `2` on the stack.

This minimal compiler has to do the following: traverse the AST I pass in, find the `*ast.IntegerLiteral` nodes, evaluate them by turning them into `*object.Integer`objects, add the objects to the constant pool, and finally emit `OpConstant`instructions that reference the constants in said pool.

Let's start by defining `Compiler`and its interface in a new `compiler`package:
```go
// compiler/compiler.go
package compiler

type Compiler struct {
	instructions code.Instructions
	constants []object.Object
}

func New() *Compiler {
	return &Compiler{
		instructions: code.Instructions{},
		constants: []object.Objects{},
	}
}

func (c *Compiler) Compile(node ast.Node) error {
	return nil
}

func (c *Compiler) Bytecode() *Bytecode {
	return &Bytecode{
		Instructions: c.instructions,
		Constants: c.constants,
	}
}

type Bytecode struct {
	Instructions code.Instructions
	Constants []object.Object
}
```

The `Compiler` is a small `struct`with only two fields: `instructions`and `constants`. Both are internal fields and will later be modified by the `Compile` method. `instructions`will hold the generated bytecode and `constants`is a slice that serves as my constant pool.
`Bytecode` contains the `Instructions`the compiler generated and the `Constants`the compiler evaluated. `Bytecode` is what I'll pass to the VM and make assertions about in my compiler tests. 

```go
// compiler/compiler_test.go

package compiler

type compilerTestCase struct {
	input string
	expectedConstants []interface{}
	expectedInstructions []code.Instructions
}

func TestIntegerArithmetic(t *testing.T) {
	tests := []compilerTestCase{
	{
		input: "1 + 2",
		expectedConstants: []interface{}{1, 2},
		expectedInstructions: []code.Instructions{
			code.Make(code.OpConstant, 0),
			code.Make(code.OpConstant, 1),
		},
	},
}

runCompilerTests(t, tests)
}

func runCompilerTests(t *Testing.T, tests []compilerTestCase) {
	t.Helper()

	for _, tt := range tests {
		program := parse(tt.input)

		compiler := New()
		err := compiler.Compile(program)
		if err != nil {
			t.Faltalf("compiler error: %s", err)
		}

		bytecode := compiler.Bytecode()

		err := testInstructions(tt.expectedInstructions, bytecode.Instructions)
		if err != nil {
			t.Fatalf("testInstructions failed: %s", err)
		}

		err := testConstants(t, tt.expectedConstants, bytecode.Constants)
		if err != nil {
			t.Fatalf("testConstants failed: %s", err)
		}
	}
}
```
I take Monkey code as input, parse it, produce an AST, hand it to the compiler and then make assertions about the bytecode the compiler produced. I do that by constructing a `compilerTestCase` in which we define the input, which constants we expect in the constant pool and which instructions we expect the compiler to generate. Then I hand the `tests` slice with the `compilerTestCases` to `runCompilerTests` to run them.

Now, about the helpers:

```go
// compiler/compiler_test.go

import ()

func parse(input string) *ast.Program {
	l := lexer.New(input)
	p := parser.New(l)
	return p.ParseProgram()
}
``` 

That's the prelude. The main part of `runCompilerTests` resolved around the two fields of the `Bytecode`the compiler produced. First, I want to make sure that the `bytecode.Instructions` are correct:

```go
// compiler/compiler_test.go

import ()

func testInstructions(
	expected []code.Instructions,
	actual code.Instructions,
) error {
	concatted := concatInstructions(expected)

	if len(actual) != len(concatted) {
		return fmt.Errorf("_wrong instructions length.\nwant=%q\ngot=%q", concatted, actual)
	}

	for i, ins := range concatted {
		if actual[i] != ins {
			return fmt.Errorf("_wrong instruction at %d.\nwant=%q\ngot=%q", i, concatted, actual)
		}
	}

	return nil
}
```

And it uses another helper called `concatInstructions:
```go
// compiler/compiler_test.go

func concatInstructions(s []code.Instructions) code.Instructions {
	out := code.Instructions{}

	for _, ins := range s {
		out = append(out, ins...)
	}

	return out
}
```

This helper is needed, because the `expectedInstructions` field in `compilerTestCase` is not just a slice of bytes, but a slice of *slices* of bytes. And that's because I use `code.Make`to generate the `expectedInstructions`, which produces a `[]byte`. So in order to compare the `expectedInstructions` with the actual instructions, I need to turn the slice of slices into a flattened slice by concatenating the instructions.

The other helper is `testConstants`, which resembles a lot of the test helpers I used in `evaluator` package:

```go
// compiler/compier_test.go

func testConstants(
	t *testing.T,
	expected []inteface{},
	actual []object.Object,
) error {
	if len(expected) != len(actual) {
		return fmt.Errorf("wrong number of constants. got=%d, want=%d", len(actual), len(expected))
	}

	for i, constant := range expected {
		switch constant := constant.(type) {
			case int:
				err := testIntegerObject(int64(constant), actual[i])
				if err != nil {
					return fmt.Errorf("constant %d - testIntegerObject failed: %s", i, err)
				}
		}
	}

	return nil
}
```

This function iterates through the `expected`constants and compares them with the `actual` constants the compiler produced. The `switch` is a sign of things to come. It will increase as I expect more than integers to end up in the constant pool. And the other helper:

```go
// compiler/compiler_test.go

func testIntegerObject(expected int64, actual object.Object) error {
	result, ok := actual.(*object.Integer)
	if !ok {
		return fmt.Errorf("object is not Integer. got=%T (%+v", actual, actual)
	}

	if result.Value != expected {
		return _fmt.Errorf("object has wrong value. got=%d, want=%d", result.Value, expected)
	}

	return nil
}
```

![[the-smallest-compiler.png]]